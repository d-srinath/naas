#!/bin/bash
# NAAS Bundle - Copy this entire file and run: bash bundle.txt
# This extracts the essential files for namespace-config-to-helm-values

set -e
echo "Extracting naas files..."

# Create directories
mkdir -p scripts
mkdir -p charts/namespace-onboarding/templates

# ============== scripts/convert_all.py ==============
cat > scripts/convert_all.py << 'ENDFILE'
#!/usr/bin/env python3
"""
Convert legacy team configs (project.properties + *-quotas.yml) into Helm values YAML per env.

Input:
  input/<team>/
    - project.properties
    - <team>-<env>-quotas.yml (1..N)

Output:
  output/<team>/<env>.yaml
"""

from __future__ import annotations
import sys
import re
from pathlib import Path
from typing import Dict, Any, List, Tuple
import argparse

import yaml


# ----------------------------
# CONFIG (edit as needed)
# ----------------------------
DEFAULT_INPUT_ROOT = Path("input")
DEFAULT_OUTPUT_ROOT = Path("output")

# explicit 1:1 mapping from properties keys to Helm values keys
# Output keys support dot-notation for nesting.
KEY_MAP = {
    "PROJECT_DOMAIN": "project.domain",
    "PROJECT_MANAGER": "project.manager",
    "PROJECT_CODE": "project.code",
    "PROJECT_COST_CENTER": "project.cost_center",
    "CREATED_DATE": "project.create_date",
    "CREATED_BY": "project.created_by",
    "CMDB_APPLICATION": "project.cmdb_application",
    "AD_GROUP": "adgroup",
    "REQUEST_ID": "request_id",
}

# namespace format (make configurable if needed)
DEFAULT_NAMESPACE_FMT = "{team}-{env}-1"

# filename pattern: <team>-<env>-quotas.yml
QUOTA_RE = re.compile(r"^(?P<team>.+)-(?P<env>[^-]+)-quotas\.ya?ml$")

# Kubernetes namespace validation regex (RFC 1123 label)
NAMESPACE_RE = re.compile(r'^[a-z0-9]([-a-z0-9]*[a-z0-9])?$')


# ----------------------------
# Helpers
# ----------------------------
def set_nested(d: Dict[str, Any], dotted_key: str, value: Any) -> None:
    parts = dotted_key.split(".")
    cur = d
    for p in parts[:-1]:
        if p not in cur or not isinstance(cur[p], dict):
            cur[p] = {}
        cur = cur[p]
    cur[parts[-1]] = value


def parse_properties(path: Path) -> Dict[str, Any]:
    """
    Read KEY=VALUE lines, skip blanks and comments.
    Apply KEY_MAP and build nested dict.
    """
    out: Dict[str, Any] = {}
    for raw in path.read_text().splitlines():
        line = raw.strip()
        if not line or line.startswith("#"):
            continue
        if "=" not in line:
            continue
        k, v = line.split("=", 1)
        k = k.strip()
        v = v.strip()
        if k in KEY_MAP:
            set_nested(out, KEY_MAP[k], v)
    return out


def extract_resource_quota(quota_doc: Dict[str, Any]) -> Dict[str, Any]:
    """
    Extract ResourceQuota.spec.hard and convert to Helm structure.

    Input quota_doc is expected to be either:
      - a Template-like object with `objects: [...]`
      - OR a plain ResourceQuota object
    """
    rq_obj = None

    if isinstance(quota_doc, dict) and quota_doc.get("kind") == "ResourceQuota":
        rq_obj = quota_doc
    else:
        for obj in quota_doc.get("objects", []):
            if isinstance(obj, dict) and obj.get("kind") == "ResourceQuota":
                rq_obj = obj
                break

    if not rq_obj:
        raise ValueError("No ResourceQuota object found in quota YAML")

    hard = rq_obj.get("spec", {}).get("hard", {}) or {}

    def hard_str(key: str) -> str:
        val = hard.get(key, "")
        return "" if val is None else str(val)

    # Build chart-compatible values
    out = {
        "enabled": True,
        "cpu": {
            "requests": hard_str("requests.cpu"),
            "limits": hard_str("limits.cpu"),
        },
        "memory": {
            "requests": hard_str("requests.memory"),
            "limits": hard_str("limits.memory"),
        },
        "storage": hard_str("requests.storage"),
        "pods": hard_str("pods"),
    }

    # remove empty pods if not set
    if not out["pods"]:
        out.pop("pods", None)

    return out


def validate_namespace(namespace: str) -> Tuple[bool, str]:
    """
    Validate namespace against Kubernetes naming rules (RFC 1123 label).
    Returns (is_valid, error_message).
    """
    if not namespace:
        return False, "namespace is empty"
    if len(namespace) > 63:
        return False, f"namespace too long ({len(namespace)} chars, max 63)"
    if not NAMESPACE_RE.match(namespace):
        return False, "invalid characters (must be lowercase alphanumeric or '-', start/end with alphanumeric)"
    return True, ""


def convert_team(
    team_dir: Path,
    output_root: Path,
    namespace_fmt: str,
    errors: List[Tuple[str, str, str]],
) -> int:
    """
    Convert a team's config files to Helm values.
    Returns count of successfully converted namespaces.
    Appends errors to the errors list instead of stopping.
    Each error is (namespace_id, file_path, error_message).
    """
    team = team_dir.name
    success_count = 0

    props_path = team_dir / "project.properties"
    if not props_path.exists():
        errors.append((f"{team}", str(props_path), "file not found"))
        print(f"SKIP {team}: missing project.properties")
        return 0

    try:
        team_props = parse_properties(props_path)
    except Exception as e:
        errors.append((f"{team}", str(props_path), f"failed to parse: {e}"))
        print(f"SKIP {team}: failed to parse project.properties: {e}")
        return 0

    out_dir = output_root / team
    out_dir.mkdir(parents=True, exist_ok=True)

    quota_files = sorted(team_dir.glob("*-quotas.y*ml"))
    if not quota_files:
        errors.append((f"{team}", str(team_dir), "no quota files found in directory"))
        print(f"SKIP {team}: no quota files found")
        return 0

    for qf in quota_files:
        m = QUOTA_RE.match(qf.name)
        if not m:
            errors.append((f"{team}/{qf.name}", str(qf), "quota filename not recognized"))
            print(f"WARN {team}: quota filename not recognized: {qf.name}")
            continue
        env = m.group("env")
        ns_id = f"{team}/{env}"

        try:
            namespace = namespace_fmt.format(team=team, env=env)
        except Exception as e:
            errors.append((ns_id, str(qf), f"failed to format namespace: {e}"))
            print(f"FAIL {ns_id}: failed to format namespace: {e}")
            continue

        # Validate namespace name
        is_valid, validation_error = validate_namespace(namespace)
        if not is_valid:
            errors.append((ns_id, str(qf), f"invalid namespace '{namespace}': {validation_error}"))
            print(f"FAIL {ns_id}: invalid namespace '{namespace}': {validation_error}")
            continue

        try:
            doc = yaml.safe_load(qf.read_text())
        except Exception as e:
            errors.append((ns_id, str(qf), f"failed to parse YAML: {e}"))
            print(f"FAIL {ns_id}: failed to parse quota YAML: {e}")
            continue

        try:
            resource_quota = extract_resource_quota(doc)
        except Exception as e:
            errors.append((ns_id, str(qf), f"failed to extract ResourceQuota: {e}"))
            print(f"FAIL {ns_id}: failed to extract ResourceQuota: {e}")
            continue

        values = {
            "team": team,
            "namespace": namespace,
            "project": {
                "domain": "",
                "manager": "",
                "code": "",
                "cost_center": "",
                "create_date": "",
                "created_by": "",
                "cmdb_application": "",
            },
            "adgroup": "",
            "request_id": "",
            "repositories": [],
            "applications": [],
            "resourceQuota": {
                "enabled": False,
                "cpu": {"requests": "", "limits": ""},
                "memory": {"requests": "", "limits": ""},
                "storage": "",
            },
        }

        # merge mapped properties
        # (team_props already has nested structure)
        def deep_merge(dst: Dict[str, Any], src: Dict[str, Any]) -> Dict[str, Any]:
            for k, v in src.items():
                if isinstance(v, dict) and isinstance(dst.get(k), dict):
                    deep_merge(dst[k], v)
                else:
                    dst[k] = v
            return dst

        deep_merge(values, team_props)

        # set extracted quota
        values["resourceQuota"] = resource_quota

        try:
            out_file = out_dir / f"{env}.yaml"
            out_file.write_text(yaml.safe_dump(values, sort_keys=False))
            print(f"OK   {ns_id} -> {out_file}")
            success_count += 1
        except Exception as e:
            errors.append((ns_id, str(qf), f"failed to write output file: {e}"))
            print(f"FAIL {ns_id}: failed to write output file: {e}")
            continue

    return success_count


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Convert legacy team configs to Helm values files.",
    )
    parser.add_argument(
        "--input-root",
        type=Path,
        default=DEFAULT_INPUT_ROOT,
        help="Root directory containing team folders (default: input).",
    )
    parser.add_argument(
        "--output-root",
        type=Path,
        default=DEFAULT_OUTPUT_ROOT,
        help="Root directory to write converted values (default: output).",
    )
    parser.add_argument(
        "--namespace-format",
        default=DEFAULT_NAMESPACE_FMT,
        help="Namespace format string (default: '{team}-{env}-1').",
    )
    return parser.parse_args()


def main() -> int:
    args = parse_args()
    input_root = args.input_root
    output_root = args.output_root
    namespace_fmt = args.namespace_format

    if not input_root.exists():
        print(f"ERROR: input root not found: {input_root}")
        return 2

    output_root.mkdir(parents=True, exist_ok=True)

    team_dirs = [p for p in input_root.iterdir() if p.is_dir()]
    if not team_dirs:
        print(f"ERROR: no team directories under {input_root}")
        return 2

    # Track errors and success counts
    # Each error is (namespace_id, file_path, error_message)
    errors: List[Tuple[str, str, str]] = []
    total_success = 0

    for td in sorted(team_dirs):
        total_success += convert_team(td, output_root, namespace_fmt, errors)

    # Print summary
    print("")
    print("=" * 60)
    print(f"SUMMARY: {total_success} namespace(s) converted successfully")
    print(f"         {len(errors)} error(s) encountered")
    print("=" * 60)

    if errors:
        print("")
        print("PROBLEMATIC NAMESPACES:")
        print("-" * 60)
        for ns_id, file_path, error_msg in errors:
            print(f"  {ns_id}")
            print(f"    File: {file_path}")
            print(f"    Error: {error_msg}")
            print("")
        print("-" * 60)
        print(f"Total: {len(errors)} issue(s) to fix")
        print("")
        # Return 1 if there were errors but some succeeded, 2 if all failed
        return 1 if total_success > 0 else 2

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
ENDFILE

# ============== charts/namespace-onboarding/Chart.yaml ==============
cat > charts/namespace-onboarding/Chart.yaml << 'ENDFILE'
apiVersion: v2
name: namespace-onboarding
description: Creates namespace, quota, RBAC, and Argo objects using values per namespace
type: application
version: 0.1.0
appVersion: "1.0"
ENDFILE

# ============== charts/namespace-onboarding/values.yaml ==============
cat > charts/namespace-onboarding/values.yaml << 'ENDFILE'
# Default values for namespace-onboarding.
# These values are overridden per namespace by generated values files.

team: ""
namespace: ""

# Project metadata used for labels/annotations and documentation
project:
  domain: ""
  manager: ""
  code: ""
  cost_center: ""
  create_date: ""
  created_by: ""
  cmdb_application: ""

# LDAP group for admin access
adgroup: ""

# Request tracking ID
request_id: ""

# Allowed source repos for Argo project
repositories: []

# Apps to deploy (optional)
# Each application can have:
#   - name: Application name (defaults to namespace name)
#   - repoURL: Git repo or OCI registry URL
#   - path: Path within repo (for git sources)
#   - chart: Chart name (for OCI/Helm sources)
#   - targetRevision: Branch/tag/commit (default: "main")
#   - sourceType: "helm", "kustomize", or "" for plain manifests
#   - helm:
#       valueFiles: [list of values files]
applications: []

# Resource quota limits for the namespace
resourceQuota:
  enabled: false
  cpu:
    requests: ""
    limits: ""
  memory:
    requests: ""
    limits: ""
  storage: ""
  pods: ""
ENDFILE

# ============== charts/namespace-onboarding/templates/namespace.yaml ==============
cat > charts/namespace-onboarding/templates/namespace.yaml << 'ENDFILE'
apiVersion: v1
kind: Namespace
metadata:
  name: {{ .Values.namespace | quote }}
  labels:
    team: {{ .Values.team | quote }}
    project.domain: {{ .Values.project.domain | quote }}
    project.manager: {{ .Values.project.manager | quote }}
    adgroup: {{ .Values.adgroup | quote }}
ENDFILE

# ============== charts/namespace-onboarding/templates/resourcequota.yaml ==============
cat > charts/namespace-onboarding/templates/resourcequota.yaml << 'ENDFILE'
{{- if and .Values.resourceQuota .Values.resourceQuota.enabled }}
apiVersion: v1
kind: ResourceQuota
metadata:
  name: {{ printf "%s-quota" .Values.namespace | quote }}
  namespace: {{ .Values.namespace | quote }}
  labels:
    team: {{ .Values.team | quote }}
spec:
  hard:
    {{- if .Values.resourceQuota.cpu }}
    requests.cpu: {{ .Values.resourceQuota.cpu.requests | default "0" | quote }}
    limits.cpu: {{ .Values.resourceQuota.cpu.limits | default "0" | quote }}
    {{- end }}
    {{- if .Values.resourceQuota.memory }}
    requests.memory: {{ .Values.resourceQuota.memory.requests | default "0" | quote }}
    limits.memory: {{ .Values.resourceQuota.memory.limits | default "0" | quote }}
    {{- end }}
    {{- if .Values.resourceQuota.storage }}
    requests.storage: {{ .Values.resourceQuota.storage | quote }}
    {{- end }}
    {{- if .Values.resourceQuota.pods }}
    pods: {{ .Values.resourceQuota.pods | quote }}
    {{- end }}
{{- end }}
ENDFILE

# ============== charts/namespace-onboarding/templates/rolebinding.yaml ==============
cat > charts/namespace-onboarding/templates/rolebinding.yaml << 'ENDFILE'
{{- if .Values.adgroup }}
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: {{ printf "%s-admin" .Values.team | quote }}
  namespace: {{ .Values.namespace | quote }}
  labels:
    team: {{ .Values.team | quote }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: admin
subjects:
  - kind: Group
    name: {{ .Values.adgroup | quote }}
    apiGroup: rbac.authorization.k8s.io
{{- end }}
ENDFILE

# ============== charts/namespace-onboarding/templates/appproject.yaml ==============
cat > charts/namespace-onboarding/templates/appproject.yaml << 'ENDFILE'
{{- if .Values.adgroup }}
apiVersion: argoproj.io/v1alpha1
kind: AppProject
metadata:
  name: {{ .Values.namespace | quote }}
  namespace: "argocd"
  labels:
    team: {{ .Values.team | quote }}
spec:
  description: {{ printf "Project for %s - %s" .Values.team .Values.namespace | quote }}
  destinations:
    - namespace: {{ .Values.namespace | quote }}
      server: https://kubernetes.default.svc
  sourceRepos:
    {{- if .Values.repositories }}
    {{- range .Values.repositories }}
    - {{ .url | quote }}
    {{- end }}
    {{- else }}
    - "*"
    {{- end }}
{{- end }}
ENDFILE

# ============== charts/namespace-onboarding/templates/application.yaml ==============
cat > charts/namespace-onboarding/templates/application.yaml << 'ENDFILE'
{{- range .Values.applications }}
---
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: {{ .name | default $.Values.namespace | quote }}
  namespace: applications-gitops
  labels:
    team: {{ $.Values.team | quote }}
    argocd.argoproj.io/managed-by: applications-gitops
  finalizers:
    - resources-finalizer.argocd.argoproj.io
spec:
  # Use the project with the same name as the namespace
  project: {{ $.Values.namespace | quote }}
  source:
    repoURL: {{ .repoURL | quote }}
    targetRevision: {{ .targetRevision | default "main" | quote }}
    {{- if .chart }}
    # OCI chart reference
    chart: {{ .chart | quote }}
    {{- else }}
    # Git path reference
    path: {{ .path | quote }}
    {{- end }}
    {{- if eq .sourceType "helm" }}
    {{- if and .helm .helm.valueFiles }}
    helm:
      valueFiles:
        {{- range .helm.valueFiles }}
        - {{ . | quote }}
        {{- end }}
    {{- else }}
    helm: {}
    {{- end }}
    {{- else if eq .sourceType "kustomize" }}
    kustomize: {}
    {{- else }}
    # Plain directory (vanilla K8s manifests) - no special config needed
    directory:
      recurse: true
    {{- end }}
  destination:
    server: https://kubernetes.default.svc
    namespace: {{ $.Values.namespace | quote }}
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
{{- end }}
ENDFILE

echo ""
echo "Done! Files extracted:"
echo "  - scripts/convert_all.py"
echo "  - charts/namespace-onboarding/ (Chart.yaml, values.yaml, templates/*)"
echo ""
echo "Usage:"
echo "  pip install pyyaml"
echo "  python3 scripts/convert_all.py --input-root <your-input> --output-root <your-output>"
