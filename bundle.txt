#!/bin/bash
# NAAS Bundle - Copy this entire file and run: bash bundle.txt
# This extracts the essential files for namespace-config-to-helm-values

set -e
echo "Extracting naas files..."

# Create directories
mkdir -p scripts
mkdir -p charts/namespace-onboarding/templates

# ============== scripts/convert_all.py ==============
cat > scripts/convert_all.py << 'ENDFILE'
#!/usr/bin/env python3
"""
Convert legacy team configs (project.properties + *-quotas.yml) into Helm values YAML per env.

Input:
  input/<team>/
    - project.properties
    - <team>-<env>-quotas.yml (1..N)

Output:
  output/<team>/<env>.yaml
"""

from __future__ import annotations
import sys
import re
from pathlib import Path
from typing import Dict, Any, List, Tuple
import argparse

import yaml


# ----------------------------
# CONFIG (edit as needed)
# ----------------------------
DEFAULT_INPUT_ROOT = Path("input")
DEFAULT_OUTPUT_ROOT = Path("output")

# explicit 1:1 mapping from properties keys to Helm values keys
# Output keys support dot-notation for nesting.
KEY_MAP = {
    "PROJECT_DOMAIN": "project.domain",
    "PROJECT_MANAGER": "project.manager",
    "PROJECT_CODE": "project.code",
    "PROJECT_COST_CENTER": "project.cost_center",
    "CREATED_DATE": "project.create_date",
    "CREATED_BY": "project.created_by",
    "CMDB_APPLICATION": "project.cmdb_application",
    "AD_GROUP": "adgroup",
    "REQUEST_ID": "request_id",
}

# namespace format (make configurable if needed)
DEFAULT_NAMESPACE_FMT = "{team}-{env}-1"

# filename pattern: <team>-<env>-quotas.yml
QUOTA_RE = re.compile(r"^(?P<team>.+)-(?P<env>[^-]+)-quotas\.ya?ml$")

# Kubernetes namespace validation regex (RFC 1123 label)
NAMESPACE_RE = re.compile(r'^[a-z0-9]([-a-z0-9]*[a-z0-9])?$')


# ----------------------------
# Helpers
# ----------------------------
def set_nested(d: Dict[str, Any], dotted_key: str, value: Any) -> None:
    parts = dotted_key.split(".")
    cur = d
    for p in parts[:-1]:
        if p not in cur or not isinstance(cur[p], dict):
            cur[p] = {}
        cur = cur[p]
    cur[parts[-1]] = value


def parse_properties(path: Path) -> Dict[str, Any]:
    """
    Read KEY=VALUE lines, skip blanks and comments.
    Apply KEY_MAP and build nested dict.
    """
    out: Dict[str, Any] = {}
    for raw in path.read_text().splitlines():
        line = raw.strip()
        if not line or line.startswith("#"):
            continue
        if "=" not in line:
            continue
        k, v = line.split("=", 1)
        k = k.strip()
        v = v.strip()
        if k in KEY_MAP:
            set_nested(out, KEY_MAP[k], v)
    return out


def extract_resource_quota(quota_doc: Dict[str, Any]) -> Dict[str, Any]:
    """
    Extract ResourceQuota.spec.hard and convert to Helm structure.

    Input quota_doc is expected to be either:
      - a Template-like object with `objects: [...]`
      - OR a plain ResourceQuota object
    """
    rq_obj = None

    if isinstance(quota_doc, dict) and quota_doc.get("kind") == "ResourceQuota":
        rq_obj = quota_doc
    else:
        for obj in quota_doc.get("objects", []):
            if isinstance(obj, dict) and obj.get("kind") == "ResourceQuota":
                rq_obj = obj
                break

    if not rq_obj:
        raise ValueError("No ResourceQuota object found in quota YAML")

    hard = rq_obj.get("spec", {}).get("hard", {}) or {}

    def hard_str(key: str) -> str:
        val = hard.get(key, "")
        return "" if val is None else str(val)

    # Build chart-compatible values
    out = {
        "enabled": True,
        "cpu": {
            "requests": hard_str("requests.cpu"),
            "limits": hard_str("limits.cpu"),
        },
        "memory": {
            "requests": hard_str("requests.memory"),
            "limits": hard_str("limits.memory"),
        },
        "storage": hard_str("requests.storage"),
        "pods": hard_str("pods"),
    }

    # remove empty pods if not set
    if not out["pods"]:
        out.pop("pods", None)

    return out


def extract_limit_range(quota_doc: Dict[str, Any]) -> Dict[str, Any]:
    """
    Extract LimitRange objects and merge into a single Helm-compatible structure.

    Input quota_doc is expected to be either:
      - a Template-like object with `objects: [...]` containing LimitRange(s)
      - OR a plain LimitRange object

    Merges multiple LimitRanges (e.g., memory-small, cpu-medium) into one structure
    with separate Pod and Container limits.
    """
    limit_ranges: List[Dict[str, Any]] = []

    if isinstance(quota_doc, dict) and quota_doc.get("kind") == "LimitRange":
        limit_ranges.append(quota_doc)
    else:
        for obj in quota_doc.get("objects", []):
            if isinstance(obj, dict) and obj.get("kind") == "LimitRange":
                limit_ranges.append(obj)

    if not limit_ranges:
        # No LimitRange found - return disabled structure
        return {"enabled": False}

    # Initialize merged structure
    pod_limits: Dict[str, Any] = {}
    container_limits: Dict[str, Any] = {}

    def to_str(val: Any) -> str:
        return "" if val is None else str(val)

    # Process all LimitRange objects and merge their limits
    for lr in limit_ranges:
        spec_limits = lr.get("spec", {}).get("limits", []) or []
        for limit_item in spec_limits:
            limit_type = limit_item.get("type", "")

            if limit_type == "Pod":
                # Pod-level limits: min, max
                if "max" in limit_item:
                    max_vals = limit_item["max"]
                    if "cpu" in max_vals:
                        pod_limits["maxCpu"] = to_str(max_vals["cpu"])
                    if "memory" in max_vals:
                        pod_limits["maxMemory"] = to_str(max_vals["memory"])
                if "min" in limit_item:
                    min_vals = limit_item["min"]
                    if "cpu" in min_vals:
                        pod_limits["minCpu"] = to_str(min_vals["cpu"])
                    if "memory" in min_vals:
                        pod_limits["minMemory"] = to_str(min_vals["memory"])

            elif limit_type == "Container":
                # Container-level limits: min, max, default, defaultRequest
                if "max" in limit_item:
                    max_vals = limit_item["max"]
                    if "cpu" in max_vals:
                        container_limits["maxCpu"] = to_str(max_vals["cpu"])
                    if "memory" in max_vals:
                        container_limits["maxMemory"] = to_str(max_vals["memory"])
                if "min" in limit_item:
                    min_vals = limit_item["min"]
                    if "cpu" in min_vals:
                        container_limits["minCpu"] = to_str(min_vals["cpu"])
                    if "memory" in min_vals:
                        container_limits["minMemory"] = to_str(min_vals["memory"])
                if "default" in limit_item:
                    default_vals = limit_item["default"]
                    if "cpu" in default_vals:
                        container_limits["defaultCpu"] = to_str(default_vals["cpu"])
                    if "memory" in default_vals:
                        container_limits["defaultMemory"] = to_str(default_vals["memory"])
                if "defaultRequest" in limit_item:
                    default_req = limit_item["defaultRequest"]
                    if "cpu" in default_req:
                        container_limits["defaultRequestCpu"] = to_str(default_req["cpu"])
                    if "memory" in default_req:
                        container_limits["defaultRequestMemory"] = to_str(default_req["memory"])

    # Build output structure
    out: Dict[str, Any] = {"enabled": True}

    if pod_limits:
        out["pod"] = pod_limits
    if container_limits:
        out["container"] = container_limits

    # If no actual limits were found, disable
    if not pod_limits and not container_limits:
        out["enabled"] = False

    return out


def validate_namespace(namespace: str) -> Tuple[bool, str]:
    """
    Validate namespace against Kubernetes naming rules (RFC 1123 label).
    Returns (is_valid, error_message).
    """
    if not namespace:
        return False, "namespace is empty"
    if len(namespace) > 63:
        return False, f"namespace too long ({len(namespace)} chars, max 63)"
    if not NAMESPACE_RE.match(namespace):
        return False, "invalid characters (must be lowercase alphanumeric or '-', start/end with alphanumeric)"
    return True, ""


def convert_team(
    team_dir: Path,
    output_root: Path,
    namespace_fmt: str,
    errors: List[Tuple[str, str, str]],
) -> int:
    """
    Convert a team's config files to Helm values.
    Returns count of successfully converted namespaces.
    Appends errors to the errors list instead of stopping.
    Each error is (namespace_id, file_path, error_message).
    """
    team = team_dir.name
    success_count = 0

    props_path = team_dir / "project.properties"
    if not props_path.exists():
        errors.append((f"{team}", str(props_path), "file not found"))
        print(f"SKIP {team}: missing project.properties")
        return 0

    try:
        team_props = parse_properties(props_path)
    except Exception as e:
        errors.append((f"{team}", str(props_path), f"failed to parse: {e}"))
        print(f"SKIP {team}: failed to parse project.properties: {e}")
        return 0

    out_dir = output_root / team
    out_dir.mkdir(parents=True, exist_ok=True)

    quota_files = sorted(team_dir.glob("*-quotas.y*ml"))
    if not quota_files:
        errors.append((f"{team}", str(team_dir), "no quota files found in directory"))
        print(f"SKIP {team}: no quota files found")
        return 0

    for qf in quota_files:
        m = QUOTA_RE.match(qf.name)
        if not m:
            errors.append((f"{team}/{qf.name}", str(qf), "quota filename not recognized"))
            print(f"WARN {team}: quota filename not recognized: {qf.name}")
            continue
        env = m.group("env")
        ns_id = f"{team}/{env}"

        try:
            namespace = namespace_fmt.format(team=team, env=env)
        except Exception as e:
            errors.append((ns_id, str(qf), f"failed to format namespace: {e}"))
            print(f"FAIL {ns_id}: failed to format namespace: {e}")
            continue

        # Validate namespace name
        is_valid, validation_error = validate_namespace(namespace)
        if not is_valid:
            errors.append((ns_id, str(qf), f"invalid namespace '{namespace}': {validation_error}"))
            print(f"FAIL {ns_id}: invalid namespace '{namespace}': {validation_error}")
            continue

        try:
            doc = yaml.safe_load(qf.read_text())
        except Exception as e:
            errors.append((ns_id, str(qf), f"failed to parse YAML: {e}"))
            print(f"FAIL {ns_id}: failed to parse quota YAML: {e}")
            continue

        try:
            resource_quota = extract_resource_quota(doc)
        except Exception as e:
            errors.append((ns_id, str(qf), f"failed to extract ResourceQuota: {e}"))
            print(f"FAIL {ns_id}: failed to extract ResourceQuota: {e}")
            continue

        values = {
            "team": team,
            "namespace": namespace,
            "project": {
                "domain": "",
                "manager": "",
                "code": "",
                "cost_center": "",
                "create_date": "",
                "created_by": "",
                "cmdb_application": "",
            },
            "adgroup": "",
            "request_id": "",
            "repositories": [],
            "applications": [],
            "resourceQuota": {
                "enabled": False,
                "cpu": {"requests": "", "limits": ""},
                "memory": {"requests": "", "limits": ""},
                "storage": "",
            },
            "limitRange": {
                "enabled": False,
            },
        }

        # merge mapped properties
        # (team_props already has nested structure)
        def deep_merge(dst: Dict[str, Any], src: Dict[str, Any]) -> Dict[str, Any]:
            for k, v in src.items():
                if isinstance(v, dict) and isinstance(dst.get(k), dict):
                    deep_merge(dst[k], v)
                else:
                    dst[k] = v
            return dst

        deep_merge(values, team_props)

        # set extracted quota
        values["resourceQuota"] = resource_quota

        # Extract LimitRange (optional - may not exist in all quota files)
        try:
            limit_range = extract_limit_range(doc)
            values["limitRange"] = limit_range
        except Exception as e:
            # LimitRange extraction failed - log warning but continue
            print(f"WARN {ns_id}: failed to extract LimitRange (continuing): {e}")

        try:
            out_file = out_dir / f"{env}.yaml"
            out_file.write_text(yaml.safe_dump(values, sort_keys=False))
            print(f"OK   {ns_id} -> {out_file}")
            success_count += 1
        except Exception as e:
            errors.append((ns_id, str(qf), f"failed to write output file: {e}"))
            print(f"FAIL {ns_id}: failed to write output file: {e}")
            continue

    return success_count


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Convert legacy team configs to Helm values files.",
    )
    parser.add_argument(
        "--input-root",
        type=Path,
        default=DEFAULT_INPUT_ROOT,
        help="Root directory containing team folders (default: input).",
    )
    parser.add_argument(
        "--output-root",
        type=Path,
        default=DEFAULT_OUTPUT_ROOT,
        help="Root directory to write converted values (default: output).",
    )
    parser.add_argument(
        "--namespace-format",
        default=DEFAULT_NAMESPACE_FMT,
        help="Namespace format string (default: '{team}-{env}-1').",
    )
    return parser.parse_args()


def main() -> int:
    args = parse_args()
    input_root = args.input_root
    output_root = args.output_root
    namespace_fmt = args.namespace_format

    if not input_root.exists():
        print(f"ERROR: input root not found: {input_root}")
        return 2

    output_root.mkdir(parents=True, exist_ok=True)

    team_dirs = [p for p in input_root.iterdir() if p.is_dir()]
    if not team_dirs:
        print(f"ERROR: no team directories under {input_root}")
        return 2

    # Track errors and success counts
    # Each error is (namespace_id, file_path, error_message)
    errors: List[Tuple[str, str, str]] = []
    total_success = 0

    for td in sorted(team_dirs):
        total_success += convert_team(td, output_root, namespace_fmt, errors)

    # Print summary
    print("")
    print("=" * 60)
    print(f"SUMMARY: {total_success} namespace(s) converted successfully")
    print(f"         {len(errors)} error(s) encountered")
    print("=" * 60)

    if errors:
        print("")
        print("PROBLEMATIC NAMESPACES:")
        print("-" * 60)
        for ns_id, file_path, error_msg in errors:
            print(f"  {ns_id}")
            print(f"    File: {file_path}")
            print(f"    Error: {error_msg}")
            print("")
        print("-" * 60)
        print(f"Total: {len(errors)} issue(s) to fix")
        print("")
        # Return 1 if there were errors but some succeeded, 2 if all failed
        return 1 if total_success > 0 else 2

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
ENDFILE

# ============== charts/namespace-onboarding/Chart.yaml ==============
cat > charts/namespace-onboarding/Chart.yaml << 'ENDFILE'
apiVersion: v2
name: namespace-onboarding
description: Creates namespace, quota, RBAC, and Argo objects using values per namespace
type: application
version: 0.1.0
appVersion: "1.0"
ENDFILE

# ============== charts/namespace-onboarding/values.yaml ==============
cat > charts/namespace-onboarding/values.yaml << 'ENDFILE'
# Default values for namespace-onboarding.
# These values are overridden per namespace by generated values files.
# All resources are ENABLED by default - set enabled: false to disable.

team: ""
namespace: ""

# Project metadata used for labels/annotations and documentation
project:
  domain: ""
  email: ""
  manager: ""
  code: ""
  cost_center: ""
  create_date: ""
  created_by: ""
  cmdb_application: ""

# LDAP group for admin access (required for RoleBinding and AppProject)
adgroup: ""

# Request tracking ID
request_id: ""

# Allowed source repos for Argo project
repositories: []

# ArgoCD Application configuration
# Enabled by default - requires repoURL at minimum
# If repoURL is not provided, application will not be created
application:
  enabled: true
  name: ""           # defaults to namespace name
  repoURL: ""        # REQUIRED - Git repo or OCI registry URL
  path: ""           # defaults to root path
  targetRevision: "" # defaults to "main"
  chart: ""          # for OCI/Helm sources (mutually exclusive with path)
  sourceType: ""     # "helm", "kustomize", or "" for plain manifests

# Resource quota limits for the namespace (enabled by default)
resourceQuota:
  enabled: true
  cpu:
    requests: ""
    limits: ""
  memory:
    requests: ""
    limits: ""
  storage: ""
  pods: ""

# LimitRange for default/min/max resource constraints (enabled by default)
# Merged from multiple LimitRange objects in input (e.g., memory-small, cpu-medium)
limitRange:
  enabled: true
  # Pod-level limits
  pod:
    maxCpu: ""
    maxMemory: ""
    minCpu: ""
    minMemory: ""
  # Container-level limits
  container:
    maxCpu: ""
    maxMemory: ""
    minCpu: ""
    minMemory: ""
    defaultCpu: ""
    defaultMemory: ""
    defaultRequestCpu: ""
    defaultRequestMemory: ""
ENDFILE

# ============== charts/namespace-onboarding/templates/namespace.yaml ==============
cat > charts/namespace-onboarding/templates/namespace.yaml << 'ENDFILE'
apiVersion: v1
kind: Namespace
metadata:
  name: {{ .Values.namespace | quote }}
  labels:
    team: {{ .Values.team | quote }}
    project.ocp.bcbsfl.com/project_domain: {{ .Values.project.domain | default "na" | quote }}
    project.ocp.bcbsfl.com/email: {{ .Values.project.email | default "" | quote }}
    project.ocp.bcbsfl.com/project_manager: {{ .Values.project.manager | default "na" | quote }}
    project.ocp.bcbsfl.com/adgroup: {{ .Values.adgroup | default "" | quote }}
    project.ocp.bcbsfl.com/project_cost_center: {{ .Values.project.cost_center | default "na" | quote }}
    project.ocp.bcbsfl.com/project_code: {{ .Values.project.code | default "" | quote }}
    project.ocp.bcbsfl.com/request_id: {{ .Values.request_id | default "" | quote }}
    project.ocp.bcbsfl.com/created_by: {{ .Values.project.created_by | default "" | quote }}
    project.ocp.bcbsfl.com/create_date: {{ .Values.project.create_date | default "" | quote }}
    project.ocp.bcbsfl.com/cmdb_application: {{ .Values.project.cmdb_application | default "na" | quote }}
    argocd.argoproj.io/managed-by: applications-gitops
ENDFILE

# ============== charts/namespace-onboarding/templates/resourcequota.yaml ==============
cat > charts/namespace-onboarding/templates/resourcequota.yaml << 'ENDFILE'
{{- if .Values.resourceQuota }}
{{- if .Values.resourceQuota.enabled }}
apiVersion: v1
kind: ResourceQuota
metadata:
  name: {{ .Values.namespace }}-quota
  namespace: {{ .Values.namespace }}
  labels:
    team: {{ .Values.team }}
    argocd.argoproj.io/managed-by: applications-gitops
spec:
  hard:
    {{- if .Values.resourceQuota.cpu }}
    requests.cpu: {{ .Values.resourceQuota.cpu.requests | quote }}
    limits.cpu: {{ .Values.resourceQuota.cpu.limits | quote }}
    {{- end }}
    {{- if .Values.resourceQuota.memory }}
    requests.memory: {{ .Values.resourceQuota.memory.requests | quote }}
    limits.memory: {{ .Values.resourceQuota.memory.limits | quote }}
    {{- end }}
    {{- if .Values.resourceQuota.storage }}
    requests.storage: {{ .Values.resourceQuota.storage | quote }}
    {{- end }}
    {{- if .Values.resourceQuota.pods }}
    pods: {{ .Values.resourceQuota.pods | quote }}
    {{- end }}
{{- end }}
{{- end }}
ENDFILE

# ============== charts/namespace-onboarding/templates/rolebinding.yaml ==============
cat > charts/namespace-onboarding/templates/rolebinding.yaml << 'ENDFILE'
{{- if .Values.adgroup }}
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: {{ .Values.team }}-admin
  namespace: {{ .Values.namespace }}
  labels:
    team: {{ .Values.team }}
    argocd.argoproj.io/managed-by: applications-gitops
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: admin
subjects:
  - kind: Group
    name: {{ .Values.adgroup }}
    apiGroup: rbac.authorization.k8s.io
{{- end }}
ENDFILE

# ============== charts/namespace-onboarding/templates/appproject.yaml ==============
cat > charts/namespace-onboarding/templates/appproject.yaml << 'ENDFILE'
{{- if .Values.adgroup }}
apiVersion: argoproj.io/v1alpha1
kind: AppProject
metadata:
  name: {{ .Values.namespace | quote }}
  namespace: applications-gitops
  labels:
    team: {{ .Values.team | quote }}
    argocd.argoproj.io/managed-by: applications-gitops
spec:
  description: {{ printf "Project for %s - %s" .Values.team .Values.namespace | quote }}

  # Only allow deploying to this specific namespace
  destinations:
    - namespace: {{ .Values.namespace | quote }}
      server: https://kubernetes.default.svc

  # Source repositories allowed for this project
  sourceRepos:
    {{- if .Values.repositories }}
    {{- range .Values.repositories }}
    - {{ .url | quote }}
    {{- end }}
    {{- else }}
    - "*"
    {{- end }}

  # Cluster resources that can be managed (none - namespace-scoped only)
  clusterResourceWhitelist: []

  # Namespace resources that can be managed
  namespaceResourceWhitelist:
    - group: '*'
      kind: '*'

  # RBAC roles for the project
  roles:
    - name: admin
      description: {{ printf "Admin access for %s - can manage resources but not create apps" .Values.adgroup | quote }}
      policies:
        # Allow all actions on applications EXCEPT create
        - p, proj:{{ .Values.namespace }}:admin, applications, get, {{ .Values.namespace }}/*, allow
        - p, proj:{{ .Values.namespace }}:admin, applications, sync, {{ .Values.namespace }}/*, allow
        - p, proj:{{ .Values.namespace }}:admin, applications, delete, {{ .Values.namespace }}/*, allow
        - p, proj:{{ .Values.namespace }}:admin, applications, update, {{ .Values.namespace }}/*, allow
        - p, proj:{{ .Values.namespace }}:admin, applications, override, {{ .Values.namespace }}/*, allow
        - p, proj:{{ .Values.namespace }}:admin, applications, action/*, {{ .Values.namespace }}/*, allow
        # Deny create operations for applications and applicationsets
        - p, proj:{{ .Values.namespace }}:admin, applications, create, {{ .Values.namespace }}/*, deny
        # Allow viewing logs and exec
        - p, proj:{{ .Values.namespace }}:admin, logs, get, {{ .Values.namespace }}/*, allow
        - p, proj:{{ .Values.namespace }}:admin, exec, create, {{ .Values.namespace }}/*, allow
      groups:
        - {{ .Values.adgroup | quote }}
{{- end }}
ENDFILE

# ============== charts/namespace-onboarding/templates/limitrange.yaml ==============
cat > charts/namespace-onboarding/templates/limitrange.yaml << 'ENDFILE'
{{- if .Values.limitRange }}
{{- if .Values.limitRange.enabled }}
apiVersion: v1
kind: LimitRange
metadata:
  name: {{ .Values.namespace }}-limits
  namespace: {{ .Values.namespace }}
  labels:
    team: {{ .Values.team }}
    argocd.argoproj.io/managed-by: applications-gitops
spec:
  limits:
    {{- if .Values.limitRange.pod }}
    - type: Pod
      {{- if or .Values.limitRange.pod.maxCpu .Values.limitRange.pod.maxMemory }}
      max:
        {{- if .Values.limitRange.pod.maxCpu }}
        cpu: {{ .Values.limitRange.pod.maxCpu | quote }}
        {{- end }}
        {{- if .Values.limitRange.pod.maxMemory }}
        memory: {{ .Values.limitRange.pod.maxMemory | quote }}
        {{- end }}
      {{- end }}
      {{- if or .Values.limitRange.pod.minCpu .Values.limitRange.pod.minMemory }}
      min:
        {{- if .Values.limitRange.pod.minCpu }}
        cpu: {{ .Values.limitRange.pod.minCpu | quote }}
        {{- end }}
        {{- if .Values.limitRange.pod.minMemory }}
        memory: {{ .Values.limitRange.pod.minMemory | quote }}
        {{- end }}
      {{- end }}
    {{- end }}
    {{- if .Values.limitRange.container }}
    - type: Container
      {{- if or .Values.limitRange.container.maxCpu .Values.limitRange.container.maxMemory }}
      max:
        {{- if .Values.limitRange.container.maxCpu }}
        cpu: {{ .Values.limitRange.container.maxCpu | quote }}
        {{- end }}
        {{- if .Values.limitRange.container.maxMemory }}
        memory: {{ .Values.limitRange.container.maxMemory | quote }}
        {{- end }}
      {{- end }}
      {{- if or .Values.limitRange.container.minCpu .Values.limitRange.container.minMemory }}
      min:
        {{- if .Values.limitRange.container.minCpu }}
        cpu: {{ .Values.limitRange.container.minCpu | quote }}
        {{- end }}
        {{- if .Values.limitRange.container.minMemory }}
        memory: {{ .Values.limitRange.container.minMemory | quote }}
        {{- end }}
      {{- end }}
      {{- if or .Values.limitRange.container.defaultCpu .Values.limitRange.container.defaultMemory }}
      default:
        {{- if .Values.limitRange.container.defaultCpu }}
        cpu: {{ .Values.limitRange.container.defaultCpu | quote }}
        {{- end }}
        {{- if .Values.limitRange.container.defaultMemory }}
        memory: {{ .Values.limitRange.container.defaultMemory | quote }}
        {{- end }}
      {{- end }}
      {{- if or .Values.limitRange.container.defaultRequestCpu .Values.limitRange.container.defaultRequestMemory }}
      defaultRequest:
        {{- if .Values.limitRange.container.defaultRequestCpu }}
        cpu: {{ .Values.limitRange.container.defaultRequestCpu | quote }}
        {{- end }}
        {{- if .Values.limitRange.container.defaultRequestMemory }}
        memory: {{ .Values.limitRange.container.defaultRequestMemory | quote }}
        {{- end }}
      {{- end }}
    {{- end }}
{{- end }}
{{- end }}
ENDFILE

# ============== charts/namespace-onboarding/templates/application.yaml ==============
cat > charts/namespace-onboarding/templates/application.yaml << 'ENDFILE'
{{- if .Values.application }}
{{- if .Values.application.enabled }}
{{- if .Values.application.repoURL }}
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: {{ .Values.application.name | default .Values.namespace }}
  namespace: applications-gitops
  labels:
    team: {{ .Values.team }}
    argocd.argoproj.io/managed-by: applications-gitops
  finalizers:
    - resources-finalizer.argocd.argoproj.io
spec:
  project: {{ .Values.namespace }}
  source:
    repoURL: {{ .Values.application.repoURL }}
    targetRevision: {{ .Values.application.targetRevision | default "main" }}
    {{- if .Values.application.chart }}
    chart: {{ .Values.application.chart }}
    {{- else }}
    path: {{ .Values.application.path | default "." }}
    {{- end }}
    {{- if eq .Values.application.sourceType "helm" }}
    helm: {}
    {{- else if eq .Values.application.sourceType "kustomize" }}
    kustomize: {}
    {{- else }}
    directory:
      recurse: true
    {{- end }}
  destination:
    server: https://kubernetes.default.svc
    namespace: {{ .Values.namespace }}
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
{{- end }}
{{- end }}
{{- end }}
ENDFILE

echo ""
echo "Done! Files extracted:"
echo "  - scripts/convert_all.py"
echo "  - charts/namespace-onboarding/"
echo "    - Chart.yaml, values.yaml"
echo "    - templates/namespace.yaml"
echo "    - templates/resourcequota.yaml"
echo "    - templates/limitrange.yaml"
echo "    - templates/rolebinding.yaml"
echo "    - templates/appproject.yaml"
echo "    - templates/application.yaml"
echo ""
echo "Usage:"
echo "  pip install pyyaml"
echo "  python3 scripts/convert_all.py --input-root <your-input> --output-root <your-output>"
